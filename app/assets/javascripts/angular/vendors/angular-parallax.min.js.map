{
version: 3,
file: "angular-parallax.min.js",
sources: [
"module.js",
"helper.js",
"parallax.js"
],
names: [ ],
mappings: "AAAA,QAAA,OAAA,cAAA,WAAA,uBAAA,sBCAA,QAAA,OAAA,wBACA,QAAA,iBACA,WACA,QAAA,GAAA,EAAA,EAAA,EAAA,GACA,MAAA,UAAA,GACA,GAAA,GAAA,IAAA,GAAA,GAAA,EAAA,MACA,OAAA,SAAA,SAAA,IAAA,EAAA,EAAA,EACA,QAAA,SAAA,IAAA,EAAA,EAAA,EACA,GAGA,OACA,eAAA,EACA,WAAA,GAAA,GAAA,IAAA,IAAA,OCbA,QAAA,OAAA,wBAAA,aACA,UAAA,cACA,aAAA,UAAA,YAAA,SAAA,EAAA,EAAA,GAKA,IAAA,GADA,GAFA,EAAA,QAAA,QAAA,eAAA,GACA,EAAA,oDAAA,MAAA,KAEA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,GAAA,SAAA,EAAA,MAAA,EAAA,IAAA,CACA,EAAA,EAAA,EACA,OAOA,GAAA,EAAA,CAIA,GAAA,GAAA,SAAA,GACA,MAAA,GAAA,GAAA,EAAA,EACA,eAAA,KAAA,MAAA,EAAA,GAAA,OAAA,KAAA,MAAA,EAAA,GAAA,SADA,IAIA,EAAA,SAAA,GACA,MAAA,GAAA,SACA,YAAA,QAAA,SAAA,EAAA,UAAA,KAAA,MAAA,EAAA,UAAA,MAAA,EAAA,UAAA,IADA,IAIA,EAAA,SAAA,EAAA,GAGA,GAFA,EAAA,MAAA,GAAA,EAAA,GAAA,EAAA,GACA,EAAA,MAAA,QAAA,EAAA,QACA,EAAA,OACA,IAAA,GAAA,KAAA,GAAA,OACA,EAAA,MAAA,GAAA,EAAA,OAAA,GAKA,QACA,OACA,EAAA,IACA,EAAA,IACA,SAAA,IACA,QAAA,IACA,OAAA,KAEA,KAAA,SAAA,EAAA,GACA,GACA,GADA,EAAA,EAAA,GAEA,GAAA,EAEA,EAAA,WACA,GAAA,GAAA,EAAA,YACA,EAAA,EAAA,uBACA,KACA,GAAA,EACA,QAAA,QAAA,GAAA,GAAA,OAAA,WAGA,GAGA,GAHA,EAAA,EACA,EAAA,GACA,EAAA,EAAA,GAEA,GACA,GAAA,EACA,IACA,EAAA,EAAA,wBAAA,IACA,UACA,EAAA,GAAA,IAAA,KAIA,IAAA,IACA,QAAA,EACA,MAAA,EAAA,KACA,MAAA,EAAA,KAGA,GAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,QAAA,EAAA,OAAA,OAEA,KAAA,GAAA,KAAA,GACA,QAAA,WAAA,EAAA,IACA,EAAA,GAAA,EAAA,GAAA,GACA,EAAA,KACA,EAAA,GAAA,EAAA,GAKA,IAAA,GAAA,QAAA,YAAA,EACA,KAAA,EACA,IAAA,IAAA,GACA,GAAA,EAAA,KAAA,EAAA,GAAA,CACA,GAAA,CACA,OAKA,IACA,EAAA,EAAA,GACA,EAAA,GAIA,GAAA,GAAA,mBAAA,GAAA,eAAA,UAEA,EAAA,IAAA,WAAA,WACA,EAAA,IAAA,mBAAA",
sourcesContent: [
"angular.module('duParallax', ['duScroll', 'duParallax.directive', 'duParallax.helper']); ",
"angular.module('duParallax.helper', []). factory('parallaxHelper', function() { function createAnimator (factor, max, min, offset) { return function(params) { var delta = factor*((offset || 0) + params.elemY); if(angular.isNumber(max) && delta > max) return max; if(angular.isNumber(min) && delta < min) return min; return delta; }; } return { createAnimator: createAnimator, background: createAnimator(-0.3, 150, -30, 50) }; }); ",
"angular.module('duParallax.directive', ['duScroll']). directive('duParallax', function($rootScope, $window, $document){ var test = angular.element('<div></div>')[0]; var prefixes = 'transform WebkitTransform MozTransform OTransform'.split(' '); //msTransform var transformProperty; for(var i = 0; i < prefixes.length; i++) { if(test.style[prefixes[i]] !== undefined) { transformProperty = prefixes[i]; break; } } //Skipping browsers withouth transform-support. //Could do fallback to margin or absolute positioning, but would most likely perform badly //so better UX would be to keep things static. if(!transformProperty){ return; } var translate3d = function(result){ if(!result.x && !result.y) return ''; return 'translate3d(' + Math.round(result.x) + 'px, ' + Math.round(result.y) + 'px, 0)'; }; var rotate = function(result) { if(!result.rotation) return ''; return ' rotate(' + (angular.isNumber(result.rotation) ? Math.round(result.rotation) + 'deg' : result.rotation) + ')'; }; var applyProperties = function(result, element) { element.style[transformProperty] = translate3d(result) + rotate(result); element.style.opacity = result.opacity; if(result.custom) { for(var property in result.custom) { element.style[property] = result.custom[property]; } } }; return{ scope : { y : '=', x : '=', rotation : '=', opacity : '=', custom : '=' }, link: function($scope, $element, $attr){ var element = $element[0]; var currentProperties; var inited = false; var onScroll = function(){ var scrollY = $document.scrollTop(); var rect = element.getBoundingClientRect(); if(!inited) { inited = true; angular.element($window).on('load', function init() { //Trigger the onScroll until position stabilizes. Don't know why this is needed. //TODO: Think of more elegant solution. var i = 0; var maxIterations = 10; var currentY = rect.top; var lastY; do { lastY = currentY; onScroll(); currentY = element.getBoundingClientRect().top; i++; } while(i < maxIterations && lastY !== currentY); }); } var param = { scrollY : scrollY, elemX: rect.left, elemY: rect.top }; var properties = { x : 0, y : 0, rotation : 0, opacity: 1, custom: undefined}; for(var key in properties){ if(angular.isFunction($scope[key])){ properties[key] = $scope[key](param); } else if($scope[key]){ properties[key] = $scope[key]; } } //Detect changes, if no changes avoid reflow var hasChange = angular.isUndefined(currentProperties); if(!hasChange) { for(key in properties){ if(properties[key] !== currentProperties[key]) { hasChange = true; break; } } } if(hasChange) { applyProperties(properties, element); currentProperties = properties; } }; $document.on('scroll touchmove', onScroll).triggerHandler('scroll'); $scope.$on('$destroy', function() { $document.off('scroll touchmove', onScroll); }); } }; }); "
],
sourceRoot: "/source/"
}